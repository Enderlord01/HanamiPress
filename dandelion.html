<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microfono e Testo Dinamico</title>
    <style>
        pre {
            font-family: "Courier New", monospace;
            font-size: 16px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .highlight {
            color: white;
            background-color: black;
        }
    </style>
</head>
<body>
    <pre id="ascii-art">
      _.--'--._
    .'. ':. ' :'.
   '`' : `. `: ':' 
  : : '.'. .'.':.`: 
  :' -`= `+ .= - `: 
  :.' .'.' :.'.`:': 
   : : .:`' .:`.': 
    '.: . :`. :.' 
      `'--,--'`  
          y 
         ( 
          \       _ 
           \    /`/` 
     _      |__/:/_  
     \`\    |\ :  / 
     _\:\_  /\ : /_ 
     \ : /_/\  :  / 
     _\ : /_/ : /` 
     \  :  /.'/` 
 jgs  `\ :/'/`` 
`^^`^`^``^^`^^^`^^`^^^`^
    </pre>

    <script>
        // Soglia per il volume (soglia piÃ¹ alta)
        const VOLUME_THRESHOLD = 0.1;

        // Otteniamo l'elemento pre con il testo dell'ASCII art
        const asciiArt = document.getElementById('ascii-art');
        
        // Funzione per aggiornare il colore del carattere (permanente)
        function highlightCharacter(index) {
            const text = asciiArt.innerHTML;
            const newText = text.split('').map((char, i) => {
                if (i === index && !char.includes('<span class="highlight">')) {
                    return `<span class="highlight">${char}</span>`;
                } else {
                    return char;
                }
            }).join('');
            asciiArt.innerHTML = newText;
        }

        // Accediamo al microfono
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const analyser = audioContext.createAnalyser();
                    const microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);

                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);

                    // Funzione per analizzare il volume
                    function checkVolume() {
                        analyser.getByteFrequencyData(dataArray);

                        let maxVolume = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            maxVolume = Math.max(maxVolume, dataArray[i]);
                        }

                        // Se il volume supera la soglia, cambiamo il colore di un carattere
                        if (maxVolume / 255 > VOLUME_THRESHOLD) {
                            const index = Math.floor(Math.random() * asciiArt.textContent.length); // Indice casuale
                            highlightCharacter(index);
                        }

                        // Riprova a verificare il volume
                        requestAnimationFrame(checkVolume);
                    }

                    checkVolume(); // Avvia il controllo del volume
                })
                .catch(function(err) {
                    console.log('Errore nell\'accesso al microfono:', err);
                });
        } else {
            alert('Il tuo browser non supporta l\'accesso al microfono.');
        }
    </script>
</body>
</html>
